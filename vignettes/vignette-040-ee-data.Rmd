---
title: "Earth Engine Risk Extraction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette-040-ee-data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Convert Data for Google Earth Engine App

***

This vignette takes the data produced so far in the `slfrsk` package and prepares it to be implemented in the interactive `slfrsk` Google Earth Engine (EE) App <https://ieco.users.earthengine.app/view/ieco-slf-riskmap>. These data are saved in the shared GoogleDrive `./slfRiskMapping/data/slfRisk/` directory. 

# Setup

Here we load the packages that allow us to reformat shapefile data and merge with the summarized potentials data visualized in `vignette-021-quadrant-plots`.

```{r setup, results='hide', message=FALSE}
library(slfrsk)
library(tidyverse)
library(rgdal)
library(rgeos)  #gSimplify
library(cleangeo) #clgeo_Clean
```

# Data preparation

## Summary data

We then read in the summary data for both `states` and `countries` from `vignette-010-tidy-data` to eventually merge with shapfiles. 

```{r read data}
data("states_summary_future")
data("countries_summary_future")
```


We now transform the `summary` data to represent scaled versions of the three potentials (**transport**, **establishment**, and **impact**). Each of these potentials are saved in new columns: `transport`, `establishment`, and two for **impact** (`impact_wine` and `impact_grape`), which include values for the corresponding potential that are $\log_{10}(value+1)$  transformed and then bounded $[0,10]$. 

To bound these values, each $\log$-transformed value undergoes the following, based on the existing input data and round to a single digit for visualization:

  - $transport_{[0,10]} = \frac{transport - \min(transport)}{\max(transport)}*10$
  - $establishment_{[0,10]} = establishment*10$
  - $impact_{[0,10]} = \frac{impact}{\max(impact)}*10$

After these transformations, we go ahead and round the raw data for reducing file size to *5 significant digits*.

```{r add the corr plot data}

#states
states_summary_future <- states_summary_future %>%
  #transport in 2 mutate steps
  mutate(transport = log10_avg_infected_mass - min(log10_avg_infected_mass)) %>%
  mutate(transport = round(x = transport / max(transport), digits = 1)*10) %>%
  #establishment
  mutate(establishment = round(x = grand_mean_max, digits = 1)*10) %>%
  #impact_wine
  mutate(impact_wine = round(x = log10_avg_wine / max(log10_avg_wine), digits = 1)*10) %>%
  #impact_grape
  mutate(impact_grape = round(x = log10_avg_prod / max(log10_avg_prod), digits = 1)*10)

#rounding
states_summary_future <- states_summary_future %>%
  mutate(grand_mean_max = signif(grand_mean_max, digits = 5),
         grand_se_max = signif(grand_se_max, digits = 5),
         avg_wine = signif(avg_wine, digits = 5),
         se_wine = signif(se_wine, digits = 5),
         log10_avg_wine = signif(log10_avg_wine, digits = 5),
         avg_yield = signif(avg_yield, digits = 5),
         se_yield = signif(se_yield, digits = 5),
         avg_prod = signif(avg_prod, digits = 5),
         se_prod = signif(se_prod, digits = 5),
         log10_avg_yield = signif(log10_avg_yield, digits = 5),
         log10_avg_prod = signif(log10_avg_prod, digits = 5),
         avg_infected_trade = formatC(signif(avg_infected_trade, digits = 5), format = "e"),
         se_trade = formatC(signif(se_trade, digits = 5), format = "e"),
         avg_infected_mass = formatC(signif(avg_infected_mass, digits = 5), format = "e"),
         se_mass = formatC(signif(se_mass, digits = 5), format = "e"),
         log10_avg_infected_trade = signif(log10_avg_infected_trade, digits = 5),
         log10_avg_infected_mass = signif(log10_avg_infected_mass, digits = 5)
         )

#countries
countries_summary_future <- countries_summary_future %>%
  #transport in 2 mutate steps
  mutate(transport = log10_avg_infected_mass - min(log10_avg_infected_mass)) %>%
  mutate(transport = round(x = transport / max(transport), digits = 1)*10) %>%
  #establishment
  mutate(establishment = round(x = grand_mean_max, digits = 1)*10) %>%
  #impact_wine
  mutate(impact_wine = round(x = log10_avg_wine / max(log10_avg_wine), digits = 1)*10) %>%
  #impact_grape
  mutate(impact_grape = round(x = log10_avg_prod / max(log10_avg_prod), digits = 1)*10)

#rounding
countries_summary_future <- countries_summary_future %>%
  mutate(grand_mean_max = signif(grand_mean_max, digits = 5),
         grand_se_max = signif(grand_se_max, digits = 5),
         avg_wine = signif(avg_wine, digits = 5),
         se_wine = signif(se_wine, digits = 5),
         log10_avg_wine = signif(log10_avg_wine, digits = 5),
         avg_yield = signif(avg_yield, digits = 5),
         se_yield = signif(se_yield, digits = 5),
         avg_prod = signif(avg_prod, digits = 5),
         se_prod = signif(se_prod, digits = 5),
         log10_avg_yield = signif(log10_avg_yield, digits = 5),
         log10_avg_prod = signif(log10_avg_prod, digits = 5),
         avg_infected_trade = formatC(signif(avg_infected_trade, digits = 5), format = "e"),
         se_trade = formatC(signif(se_trade, digits = 5), format = "e"),
         avg_infected_mass = formatC(signif(avg_infected_mass, digits = 5), format = "e"),
         se_mass = formatC(signif(se_mass, digits = 5), format = "e"),
         log10_avg_infected_trade = signif(log10_avg_infected_trade, digits = 5),
         log10_avg_infected_mass = signif(log10_avg_infected_mass, digits = 5)
         )

```

We also need to obtain the predicted invasion risk from `vignette-041-market-plot`. We have conveniently saved those data as `data/countries_risk_market.rda`, which actually is a modified version of `countries_summary_future`. We will load these data, round the new columns, and `join` by `ID` (note that`states` do not have values for these fields, as they were not evaluated this way).

For reference, please see `vignette-041-market-plot` for methods to produce `market_size` ($log_{10}(value+1)$ transformed average wine exports) and `risk` (scaled invasion risk $[1,10]$).

We also rename `market_size` to `mkt_size` to meet the ESRI shapefile column name requirements.

```{r load and merge market_risk data}
#read in market risk data
data("countries_risk")

#round similarly and rename market_size
countries_risk <- countries_risk %>%
  mutate(mkt_size = signif(market_size, digits = 5),
         risk = signif(risk, digits = 5)
         ) %>%
  dplyr::select(-market_size)

#merge the two datasets
countries_summary_future <- countries_summary_future %>%
  left_join(., countries_risk, by = "ID")

```

## Shapefiles

We use the shared GoogleDrive file that contains downloaded GADM shapefiles (<https://gadm.org/download_world.html>) for both `countries` and `states` geopolitical borders.

```{r read in the country and state shapefiles, message=FALSE, warning=FALSE}
  #shapefile of USA: data obtained from GADM: https://gadm.org/download_world.html
states <- readOGR(dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_USA_shp/gadm36_USA_1.shp", verbose = F, p4s = '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')

  #shapefile of world by countries
countries <- readOGR("/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_levels_shp/gadm36_0.shp", verbose = F, p4s = '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')

```

There are a few shapefile data entries that need to be cleaned, so we alter the names. We also removed the US from `countries`, as in other analyses.

```{r clean the shape data}
#STATES
#change DC name
#states@data$NAME_1 <- gsub(pattern = "Washington DC", replacement = "District of Columbia", x = states@data$NAME_1)

#COUNTRIES LAZY MAY WANT TO MAKE GSUB
countries@data$NAME_0[grep(pattern = "Ivoire", x = countries@data$NAME_0, value = F)] <- "Ivory Coast"
countries@data$NAME_0[grep(pattern = "ncipe", x = countries@data$NAME_0, value = F)] <- "Sao Tome and Principe"
countries@data$NAME_0[grep(pattern = "Cura", x = countries@data$NAME_0, value = F)] <- "Curacao"
countries@data$NAME_0[grep(pattern = "Saint Bart", x = countries@data$NAME_0, value = F)] <- "Saint Barthelemy"

#rm USA
countries <- countries[countries$NAME_0 != "United States",]

```

These shapefiles are rather large and unwieldly. To make the more manageable, we use `regeos::gSimplify()` to make them smaller by modifying the `tol` parameter, which is the value used in the Douglas-Peuker algorithm. For `countries`, we downsized the used file in addition to the `_lo` versions used for both `countries` and `states`.

```{r make shapefiles smaller}
#note that tol= can be modified to make the polygons simpler, larger values make the shapefile coarser
states_lo <- SpatialPolygonsDataFrame(Sr = rgeos::gSimplify(spgeom = states, topologyPreserve = TRUE, tol = 0.01), data = states@data)
countries <- SpatialPolygonsDataFrame(Sr = rgeos::gSimplify(spgeom = countries, topologyPreserve = TRUE, tol = 0.01), data = countries@data)
countries_lo <- SpatialPolygonsDataFrame(Sr = rgeos::gSimplify(spgeom = countries, topologyPreserve = TRUE, tol = 0.01), data = countries@data)

```

Following this, the shapefiles were filtered to only geopolitical entities that are in the corresponding `countries` and `states` data.

```{r filter the states to just those in the trade data}
#states
states <- states[states@data$NAME_1 %in% unique(states_summary_future$geopol_unit),]
states_lo <- states_lo[states_lo@data$NAME_1 %in% unique(states_summary_future$geopol_unit),]
#countries
countries <- countries[countries@data$NAME_0 %in% unique(countries_summary_future$geopol_unit),]
countries_lo <- countries_lo[countries_lo@data$NAME_0 %in% unique(countries_summary_future$geopol_unit),]

```

In the downscaling and filtering process, we needed to make sure that the geometries are intact and cleaned, and so we used the `clgeo_Clean()` function to ensure that the shapefiles work appropriately.

```{r make sure geometries are  clean, warning=FALSE, message=FALSE}
#check for cleaning needed?
#clgeo_SummaryReport(clgeo_CollectionReport(states))
#clgeo_SummaryReport(clgeo_CollectionReport(states_lo))
#clgeo_SummaryReport(clgeo_CollectionReport(countries))
#clgeo_SummaryReport(clgeo_CollectionReport(countries_lo))

#might as well clean them all
states <- clgeo_Clean(states)
states_lo <- clgeo_Clean(states_lo)
countries <- clgeo_Clean(countries)
countries_lo <- clgeo_Clean(countries_lo)

```

# Data merging

Now, we use `left_join()` to join the `shapefile@data` table to the corresponding `summary` data.

```{r add in the trade data}
#states
states@data <- left_join(states@data, states_summary_future, by = c("NAME_1" = "geopol_unit"))
states_lo@data <- left_join(states_lo@data, states_summary_future, by = c("NAME_1" = "geopol_unit"))
#countries
countries@data <- left_join(countries@data, countries_summary_future, by = c("NAME_0" = "geopol_unit"))
countries_lo@data <- left_join(countries_lo@data, countries_summary_future, by = c("NAME_0" = "geopol_unit"))

```

We also rename the column fields to accommodate for ESRI shapefile column name character limits. A README file exists in the GoogleDrive `./slfRiskMapping/data/slfRisk/` that outlines the keys for the old names and the shorter names used here.

```{r rename fields}
#states
colnames(states@data)[13:35] <- c("gmean_max","gse_max","wine","grapes","avg_wine","se_wine","lavg_wine","avg_yield","se_yield","avg_prod","se_prod","lavg_yield","lavg_prod","avg_itrad","se_trad","avg_imass","se_mass","lavg_itrad","lavg_imass", "transport", "establish", "imp_wine", "imp_grape")
colnames(states_lo@data)[13:35] <- c("gmean_max","gse_max","wine","grapes","avg_wine","se_wine","lavg_wine","avg_yield","se_yield","avg_prod","se_prod","lavg_yield","lavg_prod","avg_itrad","se_trad","avg_imass","se_mass","lavg_itrad","lavg_imass", "transport", "establish", "imp_wine", "imp_grape") 
#countries
colnames(countries@data)[5:27] <- c("gmean_max","gse_max","wine","grapes","avg_wine","se_wine","lavg_wine","avg_yield","se_yield","avg_prod","se_prod","lavg_yield","lavg_prod","avg_itrad","se_trad","avg_imass","se_mass","lavg_itrad","lavg_imass", "transport", "establish", "imp_wine", "imp_grape") 
colnames(countries_lo@data)[5:27] <- c("gmean_max","gse_max","wine","grapes","avg_wine","se_wine","lavg_wine","avg_yield","se_yield","avg_prod","se_prod","lavg_yield","lavg_prod","avg_itrad","se_trad","avg_imass","se_mass","lavg_itrad","lavg_imass", "transport", "establish", "imp_wine", "imp_grape") 

```

To create a streamlined dataset, we make a version that includes both `countries` and `states` together, called `combined` (for combined data).

```{r merge to a single shapefile, message=FALSE}
#create the combined data tables
comb <- countries@data %>%
  mutate(NAME_1 = NAME_0) %>%
  full_join(., states@data) %>%
  select(NAME_0,NAME_1,ID,status:mkt_size)
comb_lo <- countries_lo@data %>%
  mutate(NAME_1 = NAME_0) %>%
  full_join(., states_lo@data) %>%
  select(NAME_0,NAME_1,ID,status:mkt_size)

#change the data tables
#states
states@data <- comb %>% filter(NAME_0 == "United States")
states_lo@data <- comb %>% filter(NAME_0 == "United States")
#countries
countries@data <- comb %>% filter(NAME_0 != "United States")
countries_lo@data <- comb %>% filter(NAME_0 != "United States")

#final merge step
combined <- rbind(states, countries, makeUniqueIDs = TRUE)
combined_lo <- rbind(states_lo, countries_lo, makeUniqueIDs = TRUE)

```

# Save shapefiles for EE

The newly merged shapefiles (`countries`, `states`, and `combined` for regular and `_lo` versions) are written to the shared GoogleDrive directory `./slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_USA_with_data/` for visualization with EE.

```{r write out the shapefiles, warning=FALSE, message=FALSE}
#states
writeOGR(obj = states, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_USA_with_data/",  driver="ESRI Shapefile", layer = "states", verbose = FALSE, overwrite_layer = TRUE)
writeOGR(obj = states_lo, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_USA_with_data/",  driver="ESRI Shapefile", layer = "states_lores", verbose = FALSE, overwrite_layer = TRUE)

#countries
writeOGR(obj = countries, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_levels_with_data/",  driver="ESRI Shapefile", layer = "countries", verbose = FALSE, overwrite_layer = TRUE)
writeOGR(obj = countries_lo, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/gadm36_levels_with_data/",  driver="ESRI Shapefile", layer = "countries_lores", verbose = FALSE, overwrite_layer = TRUE)

#combined
writeOGR(obj = combined, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/combined/",  driver="ESRI Shapefile", layer = "combined", verbose = FALSE, overwrite_layer = TRUE)
writeOGR(obj = combined_lo, dsn = "/Volumes/GoogleDrive/Shared drives/slfRiskMapping/data/slfRisk/geo_shapefiles/combined/",  driver="ESRI Shapefile", layer = "combined_lores", verbose = FALSE, overwrite_layer = TRUE)
```

# Supplemental check of shapefiles 

Fortify data to test for plotting with `ggplot2`.

```{r maybe test try plotting trade data, warning=FALSE}
#states_summary_present[match(x = states@data$NAME_1, table = states_summary_present$geopol_unit),]
#states@data

#states2 <- broom::tidy(states)

#fortifying to make points
states_gg <- fortify(states_lo, region = "NAME_1")
states_gg <- left_join(states_gg, states_summary_future, by = c("id" = "geopol_unit"))

#try with all
#combined_gg <- fortify(combined_lo, region = "NAME_1")
#combined_gg <- left_join(combined_gg, comb_lo, by = c("id" = "geopol_unit"))
```

Try to plot data with `ggplot2`.

```{r try to test plot, fig.height=5, fig.width=7}
ggplot(states_gg[!states_gg$id %in% c("Alaska", "Hawaii"),]) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = transport)) +
  coord_quickmap()
ggplot(states_gg[!states_gg$id %in% c("Alaska", "Hawaii"),]) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = establishment)) +
  coord_quickmap()
ggplot(states_gg[!states_gg$id %in% c("Alaska", "Hawaii"),]) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = impact_wine)) +
  coord_quickmap()
ggplot(states_gg[!states_gg$id %in% c("Alaska", "Hawaii"),]) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = impact_grape)) +
  coord_quickmap()
```


